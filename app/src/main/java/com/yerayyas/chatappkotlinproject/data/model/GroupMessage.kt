package com.yerayyas.chatappkotlinproject.data.model

/**
 * Represents a message within a group chat conversation.
 *
 * This data class serves as the comprehensive model for group chat messages, supporting
 * advanced features like reactions, read receipts, mentions, replies, and message editing.
 * It's designed for seamless serialization with Firebase Realtime Database while providing
 * rich functionality for modern group messaging applications.
 *
 * Key features:
 * - Support for text and image message types
 * - Advanced read receipt tracking with per-user timestamps
 * - Message reactions with emoji support and user tracking
 * - Reply-to-message functionality with complete context
 * - User mentions with notification support
 * - Message editing and pinning capabilities
 * - System message support for group activities
 * - Firebase-compatible with no-argument constructor
 * - Comprehensive utility methods for common operations
 *
 * The class includes extensive read receipt management to track which users have
 * read each message, essential for group chat user experience and analytics.
 *
 * @property id A unique identifier for the message, typically generated by Firebase
 * @property groupId The unique ID of the group where this message was sent
 * @property senderId The unique ID of the user who sent the message
 * @property senderName The display name of the sender at the time of sending
 * @property senderImageUrl Optional profile image URL of the sender
 * @property message The main text content of the message, or caption for media messages
 * @property timestamp Server-side timestamp indicating when the message was created, in milliseconds
 * @property messageType The type of the message (text, image, system, etc.)
 * @property imageUrl The URL of the attached image, if [messageType] is [GroupMessageType.IMAGE]
 * @property readStatus The delivery status of the message from the sender's perspective
 * @property readBy Map of user IDs to timestamps indicating when each user read the message
 * @property isPinned Whether this message is pinned in the group for important visibility
 * @property replyToMessageId The ID of the message this message is replying to, null if not a reply
 * @property replyToMessage The complete original message being replied to, for display context
 * @property reactions Map of emoji reactions to user/timestamp maps tracking who reacted when
 * @property isEdited Whether this message has been edited after initial sending
 * @property editedAt Timestamp of the last edit, null if never edited
 * @property mentionedUsers List of user IDs that are mentioned in this message
 * @property isSystemMessage Whether this is a system-generated message (join/leave notifications)
 * @property systemMessageType The type of system activity this message represents, if applicable
 */
data class GroupMessage(
    val id: String = "",
    val groupId: String = "",
    val senderId: String = "",
    val senderName: String = "",
    val senderImageUrl: String? = null,
    val message: String = "",
    val timestamp: Long = System.currentTimeMillis(),
    val messageType: GroupMessageType = GroupMessageType.TEXT,
    val imageUrl: String? = null,
    val readStatus: ReadStatus = ReadStatus.SENT,
    val readBy: Map<String, Long> = emptyMap(), // userId -> timestamp when read
    val isPinned: Boolean = false,
    val replyToMessageId: String? = null,
    val replyToMessage: GroupMessage? = null,
    val reactions: Map<String, Map<String, Long>> = emptyMap(), // emoji -> (userId -> timestamp)
    val isEdited: Boolean = false,
    val editedAt: Long? = null,
    val mentionedUsers: List<String> = emptyList(),
    val isSystemMessage: Boolean = false,
    val systemMessageType: GroupActivityType? = null
) {
    // No-argument constructor required by Firebase
    constructor() : this(
        "", "", "", "", null, "", 0L, GroupMessageType.TEXT, null,
        ReadStatus.SENT, emptyMap(), false, null, null,
        emptyMap(), false, null, emptyList(), false, null
    )

    /**
     * Checks if the message has been read by a specific user
     */
    fun isReadBy(userId: String): Boolean = readBy.containsKey(userId)

    /**
     * Gets the timestamp of when it was read by a user
     */
    fun getReadTimestamp(userId: String): Long? = readBy[userId]

    /**
     * Gets the list of users who have read the message
     */
    fun getReadByUsers(): List<String> = readBy.keys.toList()

    /**
     * Gets the count of users who have read the message
     */
    fun getReadCount(): Int = readBy.size

    /**
     * Checks if the message has reactions
     */
    fun hasReactions(): Boolean = reactions.isNotEmpty()

    /**
     * Gets all unique reactions on the message
     */
    fun getUniqueReactions(): List<String> = reactions.keys.toList()

    /**
     * Gets the count of a specific reaction
     */
    fun getReactionCount(emoji: String): Int = reactions[emoji]?.size ?: 0

    /**
     * Checks if a user has reacted with a specific emoji
     */
    fun hasUserReacted(userId: String, emoji: String): Boolean {
        return reactions[emoji]?.containsKey(userId) == true
    }

    /**
     * Gets all reactions from a user
     */
    fun getUserReactions(userId: String): List<String> {
        return reactions.filter { it.value.containsKey(userId) }.keys.toList()
    }

    /**
     * Checks if the message is a reply to another message
     */
    fun isReply(): Boolean = replyToMessageId != null

    /**
     * Checks if the message mentions specific users
     */
    fun hasMentions(): Boolean = mentionedUsers.isNotEmpty()

    /**
     * Checks if it mentions a specific user
     */
    fun mentionsUser(userId: String): Boolean = mentionedUsers.contains(userId)

    /**
     * Gets the message content for search (without mentions)
     */
    fun getSearchableContent(): String {
        return message.replace(Regex("@\\w+"), "").trim()
    }

    /**
     * Converts the group message to ChatMessage for compatibility
     */
    fun toChatMessage(): ChatMessage {
        val compatibleMessageType = when (messageType) {
            GroupMessageType.TEXT, GroupMessageType.SYSTEM_MESSAGE,
            GroupMessageType.REPLY, GroupMessageType.PINNED_MESSAGE,
            GroupMessageType.MEMBER_JOINED, GroupMessageType.MEMBER_LEFT,
            GroupMessageType.ADMIN_PROMOTED, GroupMessageType.GROUP_CREATED,
            GroupMessageType.GROUP_NAME_CHANGED, GroupMessageType.GROUP_IMAGE_CHANGED -> MessageType.TEXT

            GroupMessageType.IMAGE -> MessageType.IMAGE
        }

        return ChatMessage(
            id = id,
            senderId = senderId,
            receiverId = groupId,
            message = message,
            timestamp = timestamp,
            messageType = compatibleMessageType,
            imageUrl = imageUrl,
            readStatus = readStatus
        )
    }

    /**
     * Checks if the message can be edited by a user
     */
    fun canBeEditedBy(userId: String): Boolean {
        val isOwner = senderId == userId
        val isNotTooOld = System.currentTimeMillis() - timestamp < (15 * 60 * 1000) // 15 minutes
        val isTextMessage = messageType == GroupMessageType.TEXT
        return isOwner && isNotTooOld && isTextMessage && !isSystemMessage
    }

    /**
     * Checks if the message can be deleted by a user
     */
    fun canBeDeletedBy(userId: String, isAdmin: Boolean): Boolean {
        val isOwner = senderId == userId
        return (isOwner || isAdmin) && !isSystemMessage
    }
}

/**
 * Represents read confirmations for a group message
 */
data class MessageReadReceipt(
    val messageId: String = "",
    val groupId: String = "",
    val readBy: Map<String, Long> = emptyMap(), // userId -> timestamp
    val deliveredTo: Map<String, Long> = emptyMap() // userId -> timestamp
) {
    constructor() : this("", "", emptyMap(), emptyMap())

    /**
     * Adds a read receipt
     */
    fun addReadReceipt(
        userId: String,
        timestamp: Long = System.currentTimeMillis()
    ): MessageReadReceipt {
        return copy(readBy = readBy + (userId to timestamp))
    }

    /**
     * Adds a delivery receipt
     */
    fun addDeliveryReceipt(
        userId: String,
        timestamp: Long = System.currentTimeMillis()
    ): MessageReadReceipt {
        return copy(deliveredTo = deliveredTo + (userId to timestamp))
    }

    /**
     * Gets the users who have read the message
     */
    fun getReadUsers(): List<String> = readBy.keys.toList()

    /**
     * Gets the users to whom the message has been delivered
     */
    fun getDeliveredUsers(): List<String> = deliveredTo.keys.toList()

    /**
     * Checks if it was read by a specific user
     */
    fun isReadBy(userId: String): Boolean = readBy.containsKey(userId)

    /**
     * Checks if it was delivered to a specific user
     */
    fun isDeliveredTo(userId: String): Boolean = deliveredTo.containsKey(userId)
}

/**
 * Message types specific to groups (extended from base MessageType)
 */
enum class GroupMessageType {
    TEXT,
    IMAGE,
    SYSTEM_MESSAGE,
    REPLY,
    PINNED_MESSAGE,
    MEMBER_JOINED,
    MEMBER_LEFT,
    ADMIN_PROMOTED,
    GROUP_CREATED,
    GROUP_NAME_CHANGED,
    GROUP_IMAGE_CHANGED
}